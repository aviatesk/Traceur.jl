using Vinyl: @overdub, @hook
using InteractiveUtils

struct Trace
  seen::Set
  warn
  maxdepth::Int
end

function Trace(w; maxdepth=typemax(Int))
  Trace(Set(), w, maxdepth)
end

struct TraceurCtx
  metadata::Trace
end

isprimitive(f) = f isa Core.Builtin || f isa Core.IntrinsicFunction

const ignored_methods = Set([@which((1,2)[1])])
const ignored_functions = Set([getproperty, setproperty!])

dispatch_type(f, args...) = typeof.((f, args))

should_analyse(tra::Trace, C::DynamicCall) = begin
  f = C.f
  T = dispatch_type(f, C.a)

  T ∉ tra.seen && f ∉ ignored_functions && !isprimitive(f) && method(C) ∉ ignored_methods && method(C).module ∉ (Core, Core.Compiler)
end

@hook ctx::TraceurCtx (fcall::Any)(fargs...) = begin
  tra = ctx.metadata
  C = DynamicCall(fcall, fargs...)

  if should_analyse(tra, C)
    push!(tra.seen, dispatch_type(fcall, fargs))
    analyse((a...) -> tra.warn(Warning(a...)), C)
  end
end

trace(w, fcall, fargs...; kwargs...) = begin
  @overdub TraceurCtx(Trace(w; kwargs...)) fcall(fargs...)
end

function tracewarns(fcall, fargs...; modules=[], kwargs...)
  trace(warning_printer(modules), fcall, fargs...; kwargs...)
end

function collectwarns(fcall, fargs...; modules=[], kwargs...)
  warnings = Warning[]
  trace(w -> push!(warnings, w), fcall, fargs...; kwargs...)
  if !isempty(modules)
    filter!(x -> getmod(x) in modules, warnings)
  end
  return warnings
end

"""
    @warnings(functioncall(args...), maxdepth=typemax(Int), modules=[])::Vector{Traceur.Warnings}

Collect all warnings generated by Traceur's analysis of the execution of `functioncall(args...)` and return them.

Optional arguments:
- `maxdepth` constrols how far Traceur recurses through the call stack.
- If `modules` is nonempty, only warnings for methods defined in one of the modules specified will be printed.
"""
macro warnings(ex, args...)
  @assert ex.head === :call "`@warnings` should be called with a function call."

  fcall = ex.args[1]
  fargs = ex.args[2:end]
  quote
    collectwarns($(esc(fcall)), $(map(esc, fargs)...); $(map(esc, args)...))
  end
end

"""
    @trace(functioncall(args...), maxdepth=2, modules=[])

Analyse `functioncall(args...)` for common performance problems and print them to
the terminal.

Optional arguments:
- `maxdepth` constrols how far Traceur recurses through the call stack.
- If `modules` is nonempty, only warnings for methods defined in one of the modules specified will be printed.
"""
macro trace(ex, args...)
  @assert ex.head === :call "`@trace` should be called with a function call."

  fcall = ex.args[1]
  fargs = ex.args[2:end]
  quote
    tracewarns($(esc(fcall)), $(map(esc, fargs)...); $(map(esc, args)...))
  end
end
