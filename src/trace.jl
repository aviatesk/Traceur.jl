using Vinyl: @overdub, @hook
import JuliaInterpreter
using InteractiveUtils

mutable struct Trace
  seen::Set
  warn
  ncall::Int
  maxcall::Int
end

Trace(w; maxcall=typemax(Int)) = Trace(Set(), w, 0, maxcall)

struct TraceurCtx
  metadata::Trace
end

isprimitive(f) = f isa Core.Builtin || f isa Core.IntrinsicFunction

const ignored_modules = Set([Core, Core.Compiler, JuliaInterpreter, JuliaInterpreter.CompiledCalls])
const ignored_functions = Set([getproperty, setproperty!])
const ignored_methods = Set([@which((1,2)[1])])

dispatch_type(f, args...) = typeof.((f, args))

should_analyse(tra::Trace, C::DynamicCall) = begin
  f = C.f
  T = dispatch_type(f, C.a)

  T ∉ tra.seen && !isprimitive(f) && method(C).module ∉ ignored_modules && f ∉ ignored_functions && method(C) ∉ ignored_methods
end

@hook ctx::TraceurCtx (fcall::Any)(fargs...) = begin
  tra = ctx.metadata
  C = DynamicCall(fcall, fargs...)

  if should_analyse(tra, C) && tra.ncall < tra.maxcall
    push!(tra.seen, dispatch_type(fcall, fargs))
    analyse((a...) -> tra.warn(Warning(a...)), C)
    tra.ncall += 1
  end
end

trace(w, fcall, fargs...; kwargs...) = begin
  @overdub TraceurCtx(Trace(w; kwargs...)) fcall(fargs...)
end

tracewarns(fcall, fargs...; modules=[], kwargs...) = begin
  trace(warning_printer(modules), fcall, fargs...; kwargs...)
end

collectwarns(fcall, fargs...; modules=[], kwargs...) = begin
  warnings = Warning[]
  trace(w -> push!(warnings, w), fcall, fargs...; kwargs...)
  if !isempty(modules)
    filter!(x -> getmod(x) in modules, warnings)
  end
  warnings
end

"""
    @warnings(f(args...), [maxcall], [modules])::Vector{Traceur.Warnings}

Collect all warnings generated by Traceur's analysis of the execution of `f(args...)` and return them.

Optional arguments:
$(""
# - `maxdepth` constrols how far Traceur recurses through the call stack. (Default: `typemax(Int)`
)
- `maxcall` constrols how many function-analysis calls Traceur can execute. (Default: `typemax(Int)`
- If `modules` is nonempty, only warnings for methods defined in one of the modules specified will be printed. (Default: `[]`)
"""
macro warnings(ex, args...)
  @assert ex.head === :call "`@warnings` should be called with a function call."

  fcall = ex.args[1]
  fargs = ex.args[2:end]
  quote
    collectwarns($(esc(fcall)), $(map(esc, fargs)...); $(map(esc, args)...))
  end
end

"""
    @trace f(args...) [maxcall] [modules]

Analyse `f(args...)` for common performance problems and print them to the terminal.

Optional arguments:
$(""
# - `maxdepth` constrols how far Traceur recurses through the call stack. (Default: `typemax(Int)`
)
- `maxcall` constrols how many function-analysis calls Traceur can execute. (Default: `typemax(Int)`
- If `modules` is nonempty, only warnings for methods defined in one of the modules specified will be printed. (Default: `[]`)
"""
macro trace(ex, args...)
  @assert ex.head === :call "`@trace` should be called with a function call."

  fcall = ex.args[1]
  fargs = ex.args[2:end]
  quote
    tracewarns($(esc(fcall)), $(map(esc, fargs)...); $(map(esc, args)...))
  end
end
